<html lang="en">
<head>

<title>Node -- Lamport Mutual Exclusion algorithm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<script src="http://cdn.peerjs.com/0.3/peer.js"></script>
<script src="../common.js"></script>

<script type="text/javascript">

var my_id;
var clock = 0;             /* Lamport logical clock */
var queue = new Array();   /* incoming requests */
var resource_busy = false; /* is it available?  */

/* Need to run on site load */
window.onload = function() {
  /* connect with the server */
  var peer = new Peer({key: '5bk60iq1kgvcayvi', debug: 3});
  var conn = peer.connect("server");
  conn.on('open', function() {
    /* wave to server */
    conn.send("hi server");
    /* set up message handlers */
    conn.on('data', function(data) {
      if (isFinite(data)) {
        /* we got our unique id */
        my_id = data;
        updateClock(null);
      } else {
        /* we got an object */
        if (data.msg == "req") {
          queue.push({id: data.id, lc: data.lc});
        } else if (data.msg == "free") {
          free(data.id);
        }
        /* TODO: more(?) */

        /* ...finaly */
        updateClock(data.lc);
      }
    });
    /* ok, after handling inputs, we decide whether or not we want access */
    if (getRandomInt(0,1)) {
      /* adding to my own queue */
      queue.push({id: my_id, lc: clock});
      /* and sending it over to all the rest */
      conn.send({msg: "req", id: my_id, lc: clock});
      /* TODO: handle response (see acq) */
    }
  });
}

/*
 * Updates the global Lamport logical clock based on a new one
 */
var updateClock = function updateClockF(new_clock) {
  if (new_clock) {
    clock = max(clock, new_clock) + 1;
  } else {
    clock += 1;
  }
  /* since clock 'ticks' periodically, we add queue checking here */
  check();
}

/*
 * Finds the request with the smallest logical clock in the global priority queue
 * Caution: Requires a non-empty queue !!
 */
var findNext = function findNextF() {
  /* queue is an array of requests in the form of: { id: <ID>, lc: <CLOCK> } */
  var m_index = 0;

  var m = queue.length;
  for (var j = 1; j < m; j += 1) {
    if (queue[j].lc > queue[m_index].lc) {
      m_index = j;
    }
  }
  return m_index;
}

/*
 * Checks for pending request and serve if possible
 */
var check = function checkF() {
  if (queue.length == 0) {
    return -1;
  }

  if (!resource_busy) {
    var next = findNext();
    if (queue[next] == my_id) {
      /* I have the resource!!! Just use it for a sec or so */
      resource_busy = true;
      setTimeout(free(my_id), 1000);
      conn.send({msg: "free", id: my_id, lc: clock});
    } else {
      resource_busy = true;
    }
  }
  return 0;
}

/*
 * Removes the request from the global priotity queue
 */
var free = function freeF(id) {
  queue.splice(id, 1);
  resource_busy = false;
  /* more... (?) */
}

</script>
</head>

<body>
  <div id="logscontainer" style="width:500px;"></div>
</body>
</html>
